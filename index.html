<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="stile.css">
  <title>Binary wings</title>
</head>

<body style="background-color:#ffffff">
<!-- ----------------------------------------------------------------------------- -->		
<div class="padnav" >
<ul class="ul1" >
  <li class="li1 nav"><a href="#home">Home</a></li>
  <li class="li1 nav"><a href="BynaryWingsPage2_.html">Worktable</a></li>
  <li class="li1 nav"><a href="BynaryWingsPage3.html">About</a></li>
</ul>
</div>
<!-- ----------------------------------------------------------------------------- -->		

 <div class="containerImgTxt">
  <img src="images/binaryswings.jpg" alt="Snow" style="width:100%;">
  <div class="centered">
  <h1 style="font-size:5vw;"><B>Binary wings</></h1>
  <h2  style="font-size:2vw;"><i>
  ...the code is like a "binary flying machine" built with words. </br>
  Let's write them!
  </i></h2>
  </div>
 
 
</div>

<!-- ----------------------------------------------------------------------------- -->
<br>

<div class="container clearfix">
<div class="contenuto">
 
 <div  align = "center" class="uno">
  <h3>
  <p>CASCADE OF POINTS</p>
  </h3>
 </div>
 <iframe src="cascadeOfPoints.js" width=100% height=660 style="background: #F0E8DC" sandbox></iframe> 
  <br>
 <ul class="ul1">
    <li><a href="run_cascadeOfPoints.html"><h2>click to run the program, then click on the appropriate arrow to return to this page</h2></a></li>
</ul>
 
 </div>
 
 <div class="sidebar">

 <div class="container_descr p2">
   <h2>
   <p>
   CASCADE OF POINTS: <i>trigonometric "lace"</i>
   <p>
    I wrote this program before knowing Processing or other languages dedicated to creativity.
    I liked the idea of creating beautiful trigonometric graphs but "far" from the periodic trend
    which usually features renderings based on the sine and cosine functions. So I first
    used a function containing third degree terms, trigonometric functions and parameters.
    As the values change, I DID NOT draw the graph joining the subsequent points with segments BUT I have drawn
    simply the points; in fact, the course of the lines would have been very confusing
    because at each cycle the values of Y "jump" up and down continuously.
    Instead the points drawn cycle after cycle are ordered and create suggestive patterns.
   
   </h2></p>
   </div>
 
 <img src="images/cascadeOfPoints_4.gif" width="19%" height="auto" alt="smiley face">  
 <img src="images/cascadeOfPoints_1.gif" width="19%" height="auto" alt="smiley face">  
 <img src="images/cascadeOfPoints_2.gif" width="19%" height="auto" alt="smiley face">  
 <img src="images/cascadeOfPoints_3.gif" width="19%" height="auto" alt="smiley face">  
 <img src="images/cascadeOfPoints_0.gif" width="19%" height="auto" alt="smiley face">  
   
   <div class="container_descr p2">  
   <p><h2>
This program show sequences. To highlight different interesting ranges of function values,
I have selected four that are repeated cyclically. The images above do not follow the order of the sequences.
NOTE THAT THE POSITION OF THE CURSOR IS IMPORTANT:
In the first image above, we see an effect that is obtained by moving the cursor over the middle (horizontally to the right) of the display window:
the points become circles with increasing diameter.
If you move the cursor over the middle (vertically downwards) the original version of sequences change completely (except the first one).
If you click, a fade is activated or deactivated for each point or circle drawn.

   </h2></p>
   </div>   
   </div>
</div>


 <div class="contenuto">
 
 <div  align = "center" class="uno">
  <h3>
  <p>MODULAR</p>
  </h3>
 </div>
 <iframe src="modular.js" width=100% height=660 style="background: #F0E8DC" sandbox></iframe> 
  <br>
<ul class="ul1">

  <li><a href="run_modular.html"><h2>click to run the program...</h2></a></li>
</ul>
</div>
 
 <div class="sidebar">

 <div class="container_descr p2">
   <h2><p>
   Modular: <i>Rotations in a modular space</i>
   </p>
   <p>
   This program produces a drawing in which the objects, when they cross over
   the edge, are also drawn on the opposite side.<br>
   If they cross a corner of the edge, they must be drawn four times.<br>
   If they cross one side of the edge, they must be drawn twice.<br>
   This "modular" way of drawing objects is the one used for static drawings in the "regular tessellations" of the floors or for the animations of famous games such as "Asteroid".<br>
   In the event that the objects rotate, the maximum encumbrance of the rotation must be considered, otherwise the position of each vertex of the object would have to be calculated each time.
   </p></h2>
 </div>
 
 <button type="button" class="collapsible"><h2>Click to open a "mermaid" summary flowchart of code </h2></button>
 
 <div class="content">

  <img src="images/mermaid.png" width="100%" height="auto" alt="smiley face">

 </div> 
 
   <img src="images/modulare_seq_0.png" width="24%" height="auto" alt="smiley face">
   <img src="images/modulare_seq_1.png" width="24%" height="auto" alt="smiley face">
   <img src="images/modulare_seq_2.png" width="24%" height="auto" alt="smiley face">
   <img src="images/modulare_seq_3.png" width="24%" height="auto" alt="smiley face">
   
   <div class="container_descr p2">  
   <p><h2>
These are the four sequences that the program shows.<br>
In the first there is a narrow border to highlight what happens when an object (a "boulder") crosses a corner or side.
The "replicated boulders" have a red colored range.<br>
In the second, the edge is wider and there are many "boulders" of different types.
From the third sequence there are no more ranges.<br>
In the fourth the edge is maximum and there is only one type of "boulder"
   </h2></p>
  </div>   
  </div>

 
</div>




 



<!-- ----------------------------------------------------------------------------- -->

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}

</script>

</body>
</html>
